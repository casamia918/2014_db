/* Generated By:JavaCC: Do not edit this line. SQLParser.java */
        import com.sleepycat.je.*;

        import java.io.File;
        import java.util.*;
        import java.util.Map.*;


        class SQLParser implements SQLParserConstants {

                public static final boolean NOT_READONLY = false;
                public static final boolean READONLY = true;

                public static final int COLNAME = 0;
                public static final int DATATYPE = 1;
                public static final int NULLITY = 2;
                public static final int KEYTYPE = 3;

                public static final int FORCOL = 0;
                public static final int REFEDTABLENAME = 1;
                public static final int REFEDCOL = 2;

                //These prefix strings are attached to each database record key's head.
                public static final String colDefPrefix = "@cd:";
                public static final String forKeyPrefix = "#fk:";
                public static final String refingPtPrefix = "!ref->:";
                public static final String refedPtPrefix = "!ref<-:";

                public static String myID = "SQL_*************> ";

                private static File myEnvPath = new File("./db");

                private static DatabaseEntry theKey = new DatabaseEntry();
                private static DatabaseEntry theData = new DatabaseEntry();

                private static MyEnv myEnv = new MyEnv();

                private static SQLParser myParser;

                public static void main (String[] args)  {
                        try {
                                myEnv.setup(myEnvPath, false);
                                initiate();
                } finally {
                                myEnv.close();
                        }
                }

                public static void initiate() {
                        System.out.println(myID);
                        myParser = new SQLParser(System.in) ;
                myParser.run();
                }

                public void run() {
                        try {
                                myParser.Command();
                        } catch (TokenMgrError tme) {
                                System.out.println("SyntaxError");

                                initiate();

                        } catch (ParseException pe) {
                                System.out.println("SyntaxError");

                                initiate();

                        } catch (Exception e) {
                                System.out.println("UndefinedError");

                                initiate();
                        }
                }

                public static void printMessage(String msg) {
                        System.out.println(myID + msg);
                }







                //********* column definition manipulation method *********//
                //		
                //    note : Every column definition related variables are handled by these methods.		
                //
                //    getter : getCol, getColInfo
                //    modifier : modifyColInfo
                //    setter : infoToCol, setColIntoHash
                //

                //

                public String getCol(String colName) {
                        return colDefHash.get(colDefPrefix + colName);
                }

                public String getColInfo(String col, int infoKind) {
                        String[] info = col.split(" ");
                        return info[infoKind];
                }

                public String modifyColInfo(String col, int infoKind, String newInfo) {
                        String[] info = col.split(" ");
            info[infoKind] = newInfo; // type check need
            String newCol = info[0];
            for(int i=1; i<4; i++){
                    newCol = newCol.concat(" "+info[i]);
            }
            return newCol;
                }

                public String infoToCol(String colName, String dataType, String nullity, String keyType) {
                        return new String(colName +" " + dataType + " " + nullity + " " + keyType);
                }

                public void setColIntoHash(String col) {
                        String colName = getColInfo(col, COLNAME);
                        colDefHash.put(colDefPrefix + colName ,col);
                }



                //********* foreign key manipulation method *********//
                //
                //    note : Every foreign key related variables are handled by these methods.
                //			 Foreign keys are composed by 3 parts
                //
                //    getter : getForKey, getForColList, getRefedTableName, getRefedColList
                //    setter : partoToForKey (to aggregate foreign key information into one string)						
                //			   setForKeyIntoHash 
                //							
                //							forColList					 refedTableName  refedColList
                //			 foreign key (<COLUMN_NAME_LIST>) referenced <TABLENAME> (<COLUMN_NAME_LIST>)
                // 
                // * for : foreign
                // * col : column
                // * refed : referenced
                // * refing : referencing

                public String getForKey(String fId) { // fId >= 1
                        return forKeyHash.get(forKeyPrefix+fId);
                }

                private String getForKeyPart(String forKey, int Part) {
                        String[] forKeyArr = forKey.split(" ");
                        return forKeyArr[Part];
                }

                public ArrayList<String> getForColList (String forKey) {
                        String forCol = getForKeyPart(forKey, FORCOL);
                        String[] forColArr = forCol.split(",");
                        return new ArrayList<String>(Arrays.asList(forColArr));
                }

                public String getRefedTableName (String forKey) {
                        return getForKeyPart(forKey, REFEDTABLENAME);
                }

                public ArrayList<String> getRefedColList (String forKey) {
                        String refedCol = getForKeyPart(forKey, REFEDCOL);
                        String[] refedColArr = refedCol.split(",");
                        return new ArrayList<String>(Arrays.asList(refedColArr));
                }

                public String partToForKey (ArrayList<String> forColList,
                                                                        String refedTableName,
                                                                        ArrayList<String> refedColList ) {

                        String forKey = new String();
                        for(int i=0; i<forColList.size(); i++) {
                                forKey = forKey.concat(forColList.get(i) + ",");
                        }
                        forKey = forKey.substring(0, forKey.length()-1);

                        forKey = forKey.concat(" " + refedTableName + " ");

                        for(int i=0; i<refedColList.size(); i++) {
                                forKey =forKey.concat(refedColList.get(i) + ",");
                        }
                        forKey = forKey.substring(0, forKey.length()-1);

                        return forKey;
                }

                public void setForKeyIntoHash(int fId, String forKey) {
                        forKeyHash.put(forKeyPrefix+fId, forKey);
                }



                //********* program global variable *********//
                //			  
                //	note : These variables are used globally in this program
                //     
                //	Hash variable : To store each kind of key/value sets.
                //					Each kind's key are attached by discrimination prefix.
                //	* refedPtHash (referenced pointing Hash)
                //			: To store each table's referenced information, 
                //			  this Hash is declared by 2 dimension Hash.
                //
                //




                String thisTableName;
                String refedTableName;
                int primaryKeyOccur;
                int forKeyOccur;

                HashMap<String, String> colDefHash; //key Prefix : @cd:
                HashMap<String, String> forKeyHash; //key Prefix : #fk:
                HashMap<String, String> refingPtHash; //key Prefix : !ref->:
                HashMap<String, HashMap<String, String> > refedPtHash; //Prefix : !ref<-:
                                                                                                                           //key1 : table name, 
                                                                                                                           //key2 : refed Col name, value2 : refing col name 

                ArrayList<String> priColList;
                ArrayList<String> forColList;

                ArrayList<String> refedTableList;
                ArrayList<String> refedColList;

//**************************************************************************//
//************************** BNF production ********************************//
//**************************************************************************//







//******************* Query *******************//
  final public void Command() throws ParseException, Exception {
    if (jj_2_1(2147483647)) {
      jj_consume_token(EXIT);
      jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SELECT:
      case CREATE:
      case INSERT:
      case DELETE:
      case DESC:
      case DROP:
      case SHOW:
        QueryList();
        jj_consume_token(EXIT);
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void QueryList() throws ParseException, Exception {
    label_1:
    while (true) {
      TryQuery();
                System.out.println(myID);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SELECT:
      case CREATE:
      case INSERT:
      case DELETE:
      case DESC:
      case DROP:
      case SHOW:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  final public void TryQuery() throws ParseException, Exception {
    try {
      Query();
    } catch (SQLException se) {
                System.out.println(se.toString());
    } catch (DatabaseException dbe) {
                System.err.println(dbe.toString());
    }
  }

  void write(Database db, String key, String data) throws ParseException, Exception {
        theKey = new DatabaseEntry(key.getBytes("UTF-8"));
        theData = new DatabaseEntry(data.getBytes("UTF-8"));
        db.put(null, theKey,theData);
  }

  String read(Database db, String key) throws ParseException, SQLException, Exception {
        theKey = new DatabaseEntry(key.getBytes("UTF-8"));
        theData = new DatabaseEntry();
        String foundData;
        if( db.get(null,theKey,theData, LockMode.DEFAULT) == OperationStatus.SUCCESS ) {
                foundData = new String(theData.getData(), "UTF-8");
        } else {
                throw new SQLException("No record found for key'" + key + "'");
        }

//	System.out.println("read db complete, key: " + key + ", foundData: " + foundData ); // remove later
        return foundData;
  }

//
// Almost every javacode and database manipulation code are positioned 
// upper method of the related method. But some are not. 
//
  final public void Query() throws ParseException, SQLException, Exception {
        Database thisTableDb;
        List<String> tableNameList;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
      CreateTable();
      jj_consume_token(SEMICOLON);
                thisTableDb = myEnv.setDatabase(thisTableName, NOT_READONLY);

                try {
            // colDefHash input, key Prefix : @cd:
            Iterator<Entry<String,String> > colIt = colDefHash.entrySet().iterator();
            while(colIt.hasNext() ){
                Entry<String,String> nowEntry = colIt.next();
                String nowKey = nowEntry.getKey();
                String nowData = nowEntry.getValue();
                write(thisTableDb, nowKey, nowData);
            }

            // forKeyHash input, key Prefix : #fk:
            Iterator<Entry<String,String> > fkIt = forKeyHash.entrySet().iterator();
            while(colIt.hasNext() ){
                Entry<String,String> nowEntry = fkIt.next();
                String nowKey = nowEntry.getKey();
                String nowData = nowEntry.getValue();
                write(thisTableDb, nowKey, nowData);
            }

            // refingPtHash input, key Prefix : !ref->:
            Iterator<Entry<String,String> > refingPtIt = refingPtHash.entrySet().iterator();
            while(refingPtIt.hasNext() ){
                Entry<String,String> nowEntry = refingPtIt.next();
                String nowKey = nowEntry.getKey();
                String nowData = nowEntry.getValue();
                write(thisTableDb, nowKey, nowData);
            }

            } finally {
                    thisTableDb.close();
            }

        //WRITE REFERENCED POINTING HASH INTO EACH TABLES;
        //source : refedPtHash 

            Iterator< Entry<String, HashMap<String, String> > > refedIt = refedPtHash.entrySet().iterator();
            Database nowRefedDb;
            while(refedIt.hasNext()) {
                Entry<String, HashMap<String, String> > nowEntry = refedIt.next();
                String nowRefedTableName = nowEntry.getKey();
                HashMap<String,String> nowRefedPtHash = nowEntry.getValue();

                try {
                         nowRefedDb = myEnv.getDb(nowRefedTableName, NOT_READONLY);
                } catch(DatabaseNotFoundException dbnfe) {
                        {if (true) throw new SQLException("ReferenceTableExistenceError");}
                }

                try{

                        Iterator<Entry<String,String> > refedIt2 = nowRefedPtHash.entrySet().iterator();
                    while(refedIt2.hasNext() ){
                        Entry<String,String> nowEntry2 = refedIt2.next();
                        String nowKey = nowEntry2.getKey();
                        String nowData = nowEntry2.getValue();
                        write(nowRefedDb, nowKey, nowData);
                    }


                } finally {
                        nowRefedDb.close();
                }

            }

                printMessage("'" + thisTableName + "' table is created");
      break;
    case DROP:
      DropTable();
      jj_consume_token(SEMICOLON);
                /*
		if( thisTableName.equals("all") ) { // remove later
		
			myEnv.removeDbAll();
			printMessage("All table dropped");
		
		} else {
		*/



                tableNameList = myEnv.getDatabaseNames();
                if( !tableNameList.contains(thisTableName) ) {
                        {if (true) throw new SQLException("NoSuchTable");}
                }

        thisTableDb = myEnv.setDatabase(thisTableName, NOT_READONLY);


                // add DropReferencedTableError






                myEnv.removeDb(thisTableName);
                printMessage("'" + thisTableName + "' table is dropped" );

                //	}

      break;
    case SHOW:
      ShowTables();
      jj_consume_token(SEMICOLON);
                tableNameList = myEnv.getDatabaseNames();

                if(tableNameList.size()==0){
                        {if (true) throw new SQLException("Show Tables No Table");}
                } else {
                        System.out.println("------------------------");
                        Iterator<String> it = tableNameList.iterator();
                        while(it.hasNext()){
                                System.out.println(it.next());
                        }
                        System.out.println("------------------------");
                }
      break;
    case DESC:
      Desc();
      jj_consume_token(SEMICOLON);
        tableNameList = myEnv.getDatabaseNames();
                if( !tableNameList.contains(thisTableName) ) {
                        {if (true) throw new SQLException("NoSuchTable");}
                }

        thisTableDb = myEnv.setDatabase(thisTableName, NOT_READONLY);
            Cursor thisDbCursor = thisTableDb.openCursor(null, null);

        try {
                theKey = new DatabaseEntry(colDefPrefix.getBytes("UTF-8") );
                theData= new DatabaseEntry();

                        System.out.println("--------------------------------------------------");
                System.out.println("table_name [" + thisTableName +"]" );
                System.out.format("%-24s%-12s%-6s%-8s%n", "column_name", "type", "null", "key");

                OperationStatus retVal = thisDbCursor.getSearchKeyRange(theKey, theData, LockMode.DEFAULT);
                if (retVal != OperationStatus.SUCCESS) {
                        {if (true) throw new SQLException("No Column in the table");}
                } else {

                        while ( retVal == OperationStatus.SUCCESS ) {

                            String nowCol = new String(theData.getData(), "UTF-8");

                            String nowColName = getColInfo(nowCol, COLNAME);
                            String nowColDataType = getColInfo(nowCol, DATATYPE);
                            String nowColNullity = getColInfo(nowCol, NULLITY);
                            String nowColKeyType = getColInfo(nowCol, KEYTYPE);
                            if(nowColKeyType.equals("NOR")) {
                                nowColKeyType = "";
                            }

                                System.out.format("%-24s", nowColName);
                                System.out.format("%-12s", nowColDataType);
                                System.out.format("%-6s", nowColNullity);
                                System.out.format("%-8s%n", nowColKeyType);

                                retVal = thisDbCursor.getNext (theKey, theData, LockMode.DEFAULT);

                        }

                        System.out.println("--------------------------------------------------");
                }

                } finally {
                thisDbCursor.close();
                thisTableDb.close();
        }
      break;
    case SELECT:
      Select();
      jj_consume_token(SEMICOLON);
      break;
    case INSERT:
      Insert();
      jj_consume_token(SEMICOLON);
      break;
    case DELETE:
      Delete();
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//******************* Create table query *******************//
  final public void CreateTable() throws ParseException, SQLException, Exception {
    jj_consume_token(CREATE);
    jj_consume_token(TABLE);
    thisTableName = TableName();
        List<String> tableNameList = myEnv.getDatabaseNames();
        if( tableNameList.contains(thisTableName) ) {
                {if (true) throw new SQLException("Create table has failed: table with the same name already exists");}
        }
    TableElementList();
  }

  final public String TableName() throws ParseException {
    jj_consume_token(LEGAL_IDENTIFIER);
                {if (true) return token.toString();}
    throw new Error("Missing return statement in function");
  }

  final public void TableElementList() throws ParseException, SQLException, Exception {
        primaryKeyOccur = 0;
        forKeyOccur = 0;
        colDefHash = new HashMap<String, String>();
        forKeyHash = new HashMap<String, String>();
        refingPtHash = new HashMap<String, String>();
        refedPtHash = new HashMap<String, HashMap<String, String> >();
        ArrayList<String> priColList = new ArrayList<String>();
        ArrayList<String> forColList = new ArrayList<String>();
        ArrayList<String> refedColList = new ArrayList<String>();
    jj_consume_token(LEFT_PAREN);
    TableElement();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      TableElement();
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void TableElement() throws ParseException, SQLException, Exception {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      ColumnDefinition();
      break;
    case PRIMARY:
    case FOREIGN:
      TableConstraintDefinition();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ColumnDefinition() throws ParseException, SQLException {
        String col;
        String colName;
        String dt;
        String nullable = "Y";
        String key = "NOR";
    colName = ColumnName();
    dt = DataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      nullable = NotNull();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
                if( colDefHash.containsKey(colDefPrefix + colName) ) {
                        {if (true) throw new SQLException("DuplicateColumnDefError");}
                }
                col = infoToCol(colName,dt,nullable,key);
                setColIntoHash(col);
  }

  final public String NotNull() throws ParseException {
    jj_consume_token(NOT);
    jj_consume_token(NULL);
          {if (true) return "N";}
    throw new Error("Missing return statement in function");
  }

  final public String ColumnName() throws ParseException {
    jj_consume_token(LEGAL_IDENTIFIER);
                {if (true) return token.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String DataType() throws ParseException, SQLException {
        int charLen;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
          {if (true) return "int";}
      break;
    case CHAR:
      jj_consume_token(CHAR);
      jj_consume_token(LEFT_PAREN);
      jj_consume_token(INT_VALUE);
                charLen = Integer.parseInt( token.toString() );
                if ( charLen < 1 ) {
                        {if (true) throw new SQLException("Char Length should be > 0");}
                }
      jj_consume_token(RIGHT_PAREN);
          {if (true) return new String("char("+charLen+")");}
      break;
    case DATE:
      jj_consume_token(DATE);
          {if (true) return "date";}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TableConstraintDefinition() throws ParseException, SQLException, Exception {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
      PrimaryKeyConstraint();
      break;
    case FOREIGN:
      ReferentialConstraint();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PrimaryKeyConstraint() throws ParseException, SQLException {
    jj_consume_token(PRIMARY);
    jj_consume_token(KEY);
    priColList = ColumnNameList();
                primaryKeyOccur++;
                if(primaryKeyOccur>1){
                        {if (true) throw new SQLException("DuplicatePrimaryKeyDefError");}
                }

                Iterator<String> it = priColList.iterator();
                while(it.hasNext()) {
                        String priColName = it.next();
                        if( !colDefHash.containsKey(colDefPrefix + priColName) ) {
                                {if (true) throw new SQLException("NonExistingColumnDefError");}
                        }
                }

                Iterator<String> it2 = priColList.iterator();
                while(it2.hasNext()) {
                        String priColName = it2.next();
                        String col = getCol(priColName);

                        String kt = getColInfo(col, KEYTYPE);
                        if(kt.equals("FOR") ) {
                                col = modifyColInfo(col, KEYTYPE, "PRI/FOR");
                        } else if (kt.equals("NOR") ) {
                                col = modifyColInfo(col, KEYTYPE, "PRI");
                        }

                        col = modifyColInfo(col, NULLITY, "N");
                        setColIntoHash(col);
                }
  }

  final public void ReferentialConstraint() throws ParseException, SQLException, Exception {
        Database refedDb;
        OperationStatus retVal;
        ArrayList<String> forColDataTypeArr = new ArrayList<String>();
        ArrayList<String> refedColDefList = new ArrayList<String>();
        ArrayList<String> refedColDataTypeArr = new ArrayList<String>();

        HashMap<String, String> thisFKRefedPtHash = new HashMap<String,String>();
    jj_consume_token(FOREIGN);
    jj_consume_token(KEY);
    forColList = ColumnNameList();
    jj_consume_token(REFERENCES);
    refedTableName = TableName();
    refedColList = ColumnNameList();
                if( forColList.size() != refedColList.size() ) {
                        {if (true) throw new SQLException("Reference Column size Error");}
                }

                if( thisTableName.equals(refedTableName) ) {
                        {if (true) throw new SQLException("Self referencing error");}
                }

                // consume foreign column data type
                Iterator<String> it1 = forColList.iterator();
                while(it1.hasNext() ) {
                        String nowForColName = it1.next();
                        if ( colDefHash.containsKey(colDefPrefix + nowForColName) ) {
                                String nowForCol = getCol(nowForColName);
                                String nowColDt = getColInfo(nowForCol, DATATYPE);
                                forColDataTypeArr.add(nowColDt);
                        } else {
                                {if (true) throw new SQLException("NonExistingColumnDefError");}
                        }

                }



                // open referenced database
                try{
                        refedDb = myEnv.getDb(refedTableName, READONLY);
                } catch (DatabaseNotFoundException dbnfe) {
                        {if (true) throw new SQLException("ReferenceTableExistenceError");}
                }


                try {
                        // read referenced column from refedDb
                        Iterator<String> refIt = refedColList.iterator();
                        while(refIt.hasNext()) {
                                String nowRefColName =  refIt.next() ;

                                System.out.println("colDefPrefix+nowRefColName : " + colDefPrefix+nowRefColName) ; // remove later
                                theKey = new DatabaseEntry( (colDefPrefix+nowRefColName).getBytes("UTF-8") );
                                theData = new DatabaseEntry();

                                retVal = refedDb.get(null, theKey, theData, LockMode.DEFAULT);

                                if(retVal == OperationStatus.SUCCESS) {
                                        refedColDefList.add( new String(theData.getData(), "UTF-8") );
                                } else {
                                        {if (true) throw new SQLException("Reference Column Existence Error");}
                                }
                        }
                } finally {
                        refedDb.close();
                }



                // check reference constraint
                Iterator<String> it2 = refedColDefList.iterator();
                int count=-1;
                while(it2.hasNext() ) {
                        String refedCol= it2.next();
                        count++;
                        String refedColDt = getColInfo(refedCol, DATATYPE);
                        if( !refedColDt.equals( forColDataTypeArr.get(count) ) ) {
                                {if (true) throw new SQLException("Reference Type Error");}
                        }

                        String refedColKt = getColInfo(refedCol, KEYTYPE);
                        if(!refedColKt.equals("PRI") && !refedColKt.equals("PRI/FOR") ) {
                                {if (true) throw new SQLException("Reference Non PrimaryKey Error");}
                        }
                }


        // setup reference relationship
        // 1) forKeyHash 2) update colDefHash's KeyType info 3) refingPtHash 4) refedPtHash in refedTable 
        // folColList(i) -> refedColList(i)

        // 1) input into forKeyHash

                forKeyOccur++;
                String fkKey = new String(forKeyPrefix + forKeyOccur);
                String fkValue = partToForKey(forColList, refedTableName, refedColList);
                forKeyHash.put(fkKey, fkValue);


        for(int i=0; i<forColList.size(); i++ ) {
                        String nowRefingColName = forColList.get(i) ;
            String nowRefedColName = refedColList.get(i);

            // 2) update colDefHash's KeyType info

            String refingColDef = getCol(nowRefingColName);

            String kt = getColInfo(refingColDef, KEYTYPE);
            if(kt.equals("PRI") ) {
                                refingColDef = modifyColInfo(refingColDef, KEYTYPE, "PRI/FOR");
                        } else if (kt.equals("NOR") ) {
                                refingColDef = modifyColInfo(refingColDef, KEYTYPE, "FOR");
                        }
                        setColIntoHash(refingColDef);

            // 3) refingPtHash  
            // this hash must write into thisTableDb in create method

            String refingPtKey = new String(refingPtPrefix + nowRefingColName);
            String refingPtValue = new String(refedTableName + " " + nowRefedColName );
            refingPtHash.put(refingPtKey, refingPtValue);

                        //4) refedPtHash
                        // this hash must write into refedTableDb in create method
            String refedPtKey = new String(refedPtPrefix + nowRefedColName);
            String refedPtValue = new String(thisTableName + " " + nowRefingColName );
            thisFKRefedPtHash.put(refedPtKey, refedPtValue);
        }

        refedPtHash.put(refedTableName, thisFKRefedPtHash);
  }

  final public ArrayList<String> ColumnNameList() throws ParseException {
        ArrayList<String> colNameList = new ArrayList<String>();
        String colName;
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
                colNameList.add(colName);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
                        colNameList.add(colName);
    }
    jj_consume_token(RIGHT_PAREN);
                {if (true) return colNameList;}
    throw new Error("Missing return statement in function");
  }

//******************* Drop table, show tables, desc query *******************//
  final public void DropTable() throws ParseException {
    jj_consume_token(DROP);
    jj_consume_token(TABLE);
    thisTableName = TableName();
  }

  final public void ShowTables() throws ParseException {
    jj_consume_token(SHOW);
    jj_consume_token(TABLES);
  }

  final public void Desc() throws ParseException {
    jj_consume_token(DESC);
    thisTableName = TableName();
  }

//******************* Select query *******************//
  final public void Select() throws ParseException {
    jj_consume_token(SELECT);
    SelectList();
    TableExpression();
  }

  final public void SelectList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      jj_consume_token(STAR);
      break;
    case LEGAL_IDENTIFIER:
      SelectedColumn();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        SelectedColumn();
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SelectedColumn() throws ParseException {
    ColumnReference();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      ColumnName();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
  }

  final public void ColumnReference() throws ParseException {
    if (jj_2_2(2147483647)) {
      TableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    ColumnName();
  }

  final public void TableExpression() throws ParseException {
    FromClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      WhereClause();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
  }

  final public void FromClause() throws ParseException {
    jj_consume_token(FROM);
    TableReferenceList();
  }

  final public void TableReferenceList() throws ParseException {
    ReferedTable();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      ReferedTable();
    }
  }

  final public void ReferedTable() throws ParseException {
    TableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      TableName();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
  }

  final public void WhereClause() throws ParseException {
    jj_consume_token(WHERE);
    BooleanValueExpression();
  }

  final public void BooleanValueExpression() throws ParseException {
    BooleanTerm();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_6;
      }
      jj_consume_token(OR);
      BooleanTerm();
    }
  }

  final public void BooleanTerm() throws ParseException {
    BooleanFactor();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
      jj_consume_token(AND);
      BooleanFactor();
    }
  }

  final public void BooleanFactor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    BooleanTest();
  }

  final public void BooleanTest() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR_STRING:
    case INT_VALUE:
    case DATE_VALUE:
    case LEGAL_IDENTIFIER:
      Predicate();
      break;
    case LEFT_PAREN:
      ParenthesizedBooleanExpression();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ParenthesizedBooleanExpression() throws ParseException {
    jj_consume_token(LEFT_PAREN);
    BooleanTerm();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_8;
      }
      jj_consume_token(OR);
      BooleanTerm();
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void Predicate() throws ParseException {
    if (jj_2_3(2147483647)) {
      ComparisonPredicate();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEGAL_IDENTIFIER:
        NullPredicate();
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void ComparisonPredicate() throws ParseException {
    CompOperand();
    jj_consume_token(COMP_OP);
    CompOperand();
  }

  final public void CompOperand() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR_STRING:
    case INT_VALUE:
    case DATE_VALUE:
      ComparableValue();
      break;
    case LEGAL_IDENTIFIER:
      ColumnReference();
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ComparableValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
      jj_consume_token(INT_VALUE);
      break;
    case CHAR_STRING:
      jj_consume_token(CHAR_STRING);
      break;
    case DATE_VALUE:
      jj_consume_token(DATE_VALUE);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NullPredicate() throws ParseException {
    if (jj_2_4(2147483647)) {
      TableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    ColumnName();
    NullOperation();
  }

  final public void NullOperation() throws ParseException {
    jj_consume_token(IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    jj_consume_token(NULL);
  }

//******************* Insert, Delete query *******************//
  final public void Insert() throws ParseException {
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    TableName();
    InsertColumnsAndSource();
  }

  final public void InsertColumnsAndSource() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      ColumnNameList();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    ValueList();
  }

  final public void ValueList() throws ParseException {
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    Value();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      Value();
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void Value() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
      break;
    case CHAR_STRING:
    case INT_VALUE:
    case DATE_VALUE:
      ComparableValue();
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Delete() throws ParseException {
    jj_consume_token(DELETE);
    jj_consume_token(FROM);
    TableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      WhereClause();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_16()) jj_scanpos = xsp;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_11()) return true;
    if (jj_scan_token(COMP_OP)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_10()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_10()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(EXIT)) return true;
    return false;
  }

  private boolean jj_3R_10() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_16() {
    if (jj_3R_10()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  private boolean jj_3R_13() {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) return true;
    }
    return false;
  }

  private boolean jj_3R_12() {
    if (jj_3R_14()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SQLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[28];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x41200000,0x41200000,0x41200000,0x10,0x0,0x8000000,0x0,0x0,0x10,0x10,0x80,0x0,0x800000,0x10,0x0,0x20000000,0x10000000,0x8000000,0x70004,0x20000000,0x0,0x70000,0x70000,0x8000000,0x4,0x10,0x70000,0x800000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1d,0x1d,0x1d,0x0,0x10300,0x0,0x3800,0x300,0x0,0x0,0x10000,0x80,0x0,0x0,0x80,0x0,0x0,0x0,0x10000,0x0,0x10000,0x10000,0x0,0x0,0x0,0x0,0x2,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SQLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SQLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SQLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SQLParser(SQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[49];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 28; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 49; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

        }
