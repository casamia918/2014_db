/* Generated By:JavaCC: Do not edit this line. SQLParser.java */
        import com.sleepycat.je.*;

        import java.io.*;
        import java.util.*;
        import java.util.regex.Pattern;
        import java.util.Map.*;
        import java.text.*;

        class SQLParser implements MyConstants, SQLParserConstants {

                private static File myEnvPath = new File("./db");
                private static DatabaseEntry theKey = new DatabaseEntry();
                private static DatabaseEntry theData = new DatabaseEntry();
                private static OperationStatus retVal;

                private static MyEnv myEnv = new MyEnv();
                public static String myID = "SQL_**********> ";
                private static SQLParser myParser;
                private static ConstraintManager myCM = new ConstraintManager();
                private static InsertManager myIM;
                private static SelectManager mySM;
                private static TupleManager myTM = new TupleManager();

                String thisTableName;
                String refedTableName;

                int pkDefOccur;
                int fkDefOccur;
                int colDefOccur;
                int refingPtOccur;
                int refedPtOccur;

                boolean selectAllColumn;
                boolean whereAllTuple;

                // Hash variable : To store each kind of key/value sets.
                // Each kind's key are attached by discrimination prefix.
                // refedPtHash is storing each table's referenced information 
                // To specify table, this hash is declared by 2 dimension hash.
                // key1 : refed table name, 
                // key2 : refed Col name, value2 : refing col name
                HashMap<String, String> thisKVHash;
                HashMap<String, String> thisConstraintHash;
                HashMap<String, String> thisColDefHash; //key Prefix : @cd
                HashMap<String, String> thisFkDefHash; //key Prefix : #fk

                ArrayList<String> thisRefingPtList; //key Prefix : !ref->
                ArrayList<String> thisRefedPtList; //key Prefix : !ref<-
                HashMap<String, ArrayList<String> > thisRefedPtHash;

                ArrayList<String> refedTableList;
                ArrayList<String> refedColList;

                ArrayList<String> priColList;
                ArrayList<String> forColList;
                ArrayList<String> insColList;
                ArrayList<String> insValList;
                ArrayList<String> selColList;

                ArrayList<String> fromTableList;
                ArrayList<String> whereTupleList;
                ArrayList<String> allCrossedTupleList;
                ArrayList<String> allColOfFromTable;
                HashMap<String, HashMap<String,String> > fromTableAllColDefHash;

                String whereQuery = null;





                public SQLParser() {}


                public static void main (String[] args)  {
                        try {
                                myEnv.setup(myEnvPath, false);
                                myIM = new InsertManager(myEnv);
                                mySM = new SelectManager(myEnv);

                                System.out.println(myID);
                                myParser = new SQLParser(System.in) ;

                        myParser.run();
                } finally {
                                myEnv.close();
                        }
                }

                public void run() {

                        while(true) {
                                try {
                                        if( myParser.Command().equals("EXIT") ) {
                                                return;
                                        }
                                } catch (TokenMgrError tme) {
                                        System.out.println("SyntaxError");
                                        //tme.printStackTrace();
                                } catch (ParseException pe) {
                                        System.out.println("SyntaxError");
                                        //pe.printStackTrace();
                                } catch (Exception e) {
                                        System.out.println("UndefinedError : " + e.toString() );
                                        //e.printStackTrace();
                                }

                                System.out.println(myID);
                        myParser.ReInit(System.in);

                        }
                }

                public static void printMessage(String msg) {
                        System.out.println(myID + msg);
                }

                public static String autoCaseModify(Collection<String> compList, String name) {
                        Iterator<String> it = compList.iterator();
                        while(it.hasNext() ){
                                String nameIt = it.next();
                                if ( name.equalsIgnoreCase( nameIt ) ) {
                                        return nameIt;
                                }
                        }
                        return null;
                }

//**************************************************************************//
//************************** BNF production ********************************//
//**************************************************************************//







//******************* Query *******************//
  final public String Command() throws ParseException, Exception {
    if (jj_2_1(2147483647)) {
      jj_consume_token(EXIT);
      jj_consume_token(SEMICOLON);
         {if (true) return "EXIT";}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SELECT:
      case CREATE:
      case INSERT:
      case DELETE:
      case DESC:
      case DROP:
      case SHOW:
        QueryList();
        jj_consume_token(EXIT);
        jj_consume_token(SEMICOLON);
         {if (true) return "EXIT";}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void QueryList() throws ParseException, Exception {
    label_1:
    while (true) {
      TryQuery();
                 System.out.println(myID);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SELECT:
      case CREATE:
      case INSERT:
      case DELETE:
      case DESC:
      case DROP:
      case SHOW:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  final public void TryQuery() throws ParseException, Exception {
    try {
      Query();
    } catch (SQLException se) {
                System.out.println(myID);
                System.out.println(se.toString());
                //se.printStackTrace();

                consumeToSemicolon();
    } catch (DatabaseException dbe) {
                System.out.println(myID);
                System.err.println(dbe.toString());
                //dbe.printStackTrace();

                consumeToSemicolon();
    }
  }

  final private void consumeToSemicolon() throws ParseException {
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXCEPT_SEMICOLON:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      jj_consume_token(EXCEPT_SEMICOLON);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
  }

  public void write(Database db, String key, String data) throws ParseException, Exception {
        theKey = new DatabaseEntry(key.getBytes("UTF-8"));
        theData = new DatabaseEntry(data.getBytes("UTF-8"));
        db.put(null, theKey,theData);
  }

  public String read(Database db, String key) throws ParseException, SQLException, Exception {
        theKey = new DatabaseEntry(key.getBytes("UTF-8"));
        theData = new DatabaseEntry();
        String foundData;
        if( db.get(null,theKey,theData, LockMode.DEFAULT) == OperationStatus.SUCCESS ) {
                foundData = new String(theData.getData(), "UTF-8");
        } else {
                throw new SQLException("No record found for key'" + key + "'");
        }

        //System.out.println("Read db complete \nkey: " + key + "  /  foundData: " + foundData );
        return foundData;
  }

  final public void Query() throws ParseException, SQLException, Exception {
        Database thisTableDb;
        List<String> tableNameList;
        thisKVHash = new HashMap<String,String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE:
      CreateTable();
      jj_consume_token(SEMICOLON);
                thisTableDb = myEnv.setDb(thisTableName, NOT_READONLY);

                try {
            // input column definition into thisColDefHash, key Prefix : @cd:
            Iterator<Entry<String,String> > colIt = thisColDefHash.entrySet().iterator();
            while(colIt.hasNext() ){
                Entry<String,String> nowEntry = colIt.next();
                String nowKey = nowEntry.getKey();
                String nowData = nowEntry.getValue();
                write(thisTableDb, nowKey, nowData);
            }

            // input foreign key into thisFkDefHash, key Prefix : #fk:
            Iterator<Entry<String,String> > fkIt = thisFkDefHash.entrySet().iterator();
            while(fkIt.hasNext() ){
                Entry<String,String> nowEntry = fkIt.next();
                String nowKey = nowEntry.getKey();
                String nowData = nowEntry.getValue();
                write(thisTableDb, nowKey, nowData);
            }

            // input referencing pointer into thisRefingPtHash, key Prefix : !ref->:
            Iterator<String> refingPtIt = thisRefingPtList.iterator();
            while(refingPtIt.hasNext() ){
                String nowKey = refingPtIt.next();
                String nowData = " ";
                write(thisTableDb, nowKey, nowData);
            }
        } finally {
                        thisTableDb.close();
                }


        //WRITE REFERENCED POINTING HASH INTO EACH TABLES;
        //source : thisRefedPtHash 

            Iterator< Entry<String, ArrayList<String> > > refedPtArrIt = thisRefedPtHash.entrySet().iterator();
        Database nowRefedDb;
        while(refedPtArrIt.hasNext()) {
                Entry<String, ArrayList<String> > nowEntry = refedPtArrIt.next();
                String nowRefedTableName = nowEntry.getKey();
                ArrayList<String> nowRefedPtArr = nowEntry.getValue();

                try {
                        // case insensitive is already checked in constraint definition sentence
                         nowRefedDb = myEnv.setDb(nowRefedTableName, NOT_READONLY);
                } catch(DatabaseNotFoundException dbnfe) {
                        {if (true) throw new ReferenceTableExistenceError();}
                }

                try{
                        Iterator<String> refedPtIt = nowRefedPtArr.iterator();
                while(refedPtIt.hasNext() ){
                        String nowKey = refedPtIt.next();
                        String nowData = " ";
                    write(nowRefedDb, nowKey, nowData);
                }

                } finally {
                        nowRefedDb.close();
                }

        }

                printMessage("'" + thisTableName + "' table is created");
      break;
    case DROP:
      DropTable();
      jj_consume_token(SEMICOLON);
                /* // remove later
		if( thisTableName.equals("all") ) { 
			myEnv.removeDbAll();
			printMessage("All table dropped");
			return;
		} 
		*/



                Database targetDb = myEnv.setDb(thisTableName, NOT_READONLY);
                // If this table is referenced by some other table, then throw error
                if( myEnv.hasKindOf(targetDb, REFEDPT_PREFIX) ) {
                        {if (true) throw new DropReferencedTableError(thisTableName);}
                }
                // Delete this table in database 
                myEnv.removeDb(thisTableName);


                // search the referencing constraint by this db from all database and delete it 
                tableNameList = myEnv.getDbNames(); // reload
                for(String nowDbName : tableNameList) {
                        Database nowSearchDb = myEnv.setDb(nowDbName, NOT_READONLY);

                        Cursor cursor = nowSearchDb.openCursor(null,null);

                        theKey = new DatabaseEntry(REFEDPT_PREFIX.getBytes("UTF-8") );
                        theData = new DatabaseEntry();

                try {
                        retVal = cursor.getSearchKeyRange(theKey, theData, LockMode.DEFAULT);
                        while(retVal == OperationStatus.SUCCESS) {
                                String nowKey = new String(theKey.getData(), "UTF-8");
                                String nowData = new String(theData.getData(), "UTF-8");

                                String[] splited = nowKey.split("\u005c"");
                                if(REFEDPT_PREFIX.equals(splited[0]) ) {
                                        String objTable = myCM.getRefPtPart(nowKey, OBJECT_TABLENAME);
                                        if(thisTableName.equalsIgnoreCase(objTable) ) {
                                                cursor.delete();
                                        }
                                }

                                retVal = cursor.getNext(theKey, theData, LockMode.DEFAULT);
                        }

                } finally {
                        cursor.close();
                        nowSearchDb.close();
                }

                }


                printMessage("'" + thisTableName + "' table is dropped" );
      break;
    case SHOW:
      ShowTables();
      jj_consume_token(SEMICOLON);
                tableNameList = myEnv.getDbNames();

                if(tableNameList.size()==0){
                        {if (true) throw new ShowTablesNoTable();}
                } else {
                        System.out.println("-----------------------------------------------------------");
                        Iterator<String> it = tableNameList.iterator();
                        while(it.hasNext()){
                                System.out.println(it.next());
                        }
                        System.out.println("-----------------------------------------------------------");
                }
      break;
    case DESC:
      Desc();
      jj_consume_token(SEMICOLON);
                /* // remove later 
		if(thisTableName.equals("all")) {
			for(String dbNameIt : myEnv.getDbNames() ){
				doDesc(dbNameIt);
			}
		} else {
			doDesc(thisTableName);	
		}
		*/
                printDesc(thisTableName);
      break;
    case SELECT:
      Select();
      jj_consume_token(SEMICOLON);
                printSelect();
      break;
    case INSERT:
      Insert();
      jj_consume_token(SEMICOLON);
            myIM.doInsert(thisTableName, insColList, insValList);

                printMessage("The row is inserted");
      break;
    case DELETE:
      Delete();
      jj_consume_token(SEMICOLON);
                if( whereAllTuple ) {
                        int del = myEnv.deleteAllTp(thisTableName);
                        printMessage("All tuples, number of " + del + " are deleted");
                } else {
                        int[] delAndUndel = new int[2];
                        delAndUndel = myIM.doDelete(thisTableName, whereTupleList);
                        printMessage(delAndUndel[0] + " row(s) are deleted" );
                        printMessage(delAndUndel[1] + " row(s) are not deleted due to referential integrity" );
                }
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  public void printDesc(String tableName) throws ParseException, Exception {
        Database tableDb = myEnv.setDb(tableName, READONLY);
    Cursor dbCursor = tableDb.openCursor(null, null);

    try {
        theKey = new DatabaseEntry(COLDEF_PREFIX.getBytes("UTF-8") );
        theData= new DatabaseEntry();

                System.out.println("-----------------------------------------------------------");
                System.out.println("table_name [" + tableName +"]" );
                System.out.format("%-24s%-12s%-6s%-8s%n", "column_name", "type", "null", "key");

        retVal = dbCursor.getSearchKeyRange(theKey, theData, LockMode.DEFAULT);
        if (retVal != OperationStatus.SUCCESS) {
                throw new SQLException("No Column in the table");
        } else {

                while ( retVal == OperationStatus.SUCCESS ) {

                    String nowColDef = new String(theData.getData(), "UTF-8");

                    String nowColName = myCM.getColDefAttr(nowColDef, COLNAME);
                    String nowColDataType = myCM.getColDefAttr(nowColDef, DATATYPE);
                    String nowColNullity = myCM.getColDefAttr(nowColDef, NULLITY);
                    String nowColKeyType = myCM.getColDefAttr(nowColDef, KEYTYPE);
                    if(nowColKeyType.equals("NOR")) {
                        nowColKeyType = "";
                    }

                        System.out.format("%-24s", nowColName);
                        System.out.format("%-12s", nowColDataType);
                        System.out.format("%-6s", nowColNullity);
                        System.out.format("%-8s%n", nowColKeyType);

                        retVal = dbCursor.getNext (theKey, theData, LockMode.DEFAULT);

                }

               System.out.println("-----------------------------------------------------------");
        }


                /* //remove later */

                String sData;
                String sKey;

                theKey = new DatabaseEntry();
                theData = new DatabaseEntry();

                retVal = dbCursor.getFirst(theKey, theData, LockMode.DEFAULT);

                while(retVal == OperationStatus.SUCCESS) {
                        sKey = new String(theKey.getData(), "UTF-8");
                        sData = new String(theData.getData(), "UTF-8");

                        System.out.printf("%-30s      %-50s %n", sKey, sData);

                        retVal = dbCursor.getNext(theKey, theData, LockMode.DEFAULT);
                }

                System.out.println("-----------------------------------------------------------");


        } finally {
        dbCursor.close();
        tableDb.close();
    }
  }

  public void printSelect() throws ParseException, Exception, SQLException {
        ArrayList<Integer> colWidthList = new ArrayList<Integer>();
        ArrayList<String> selColListNoTableName = new ArrayList<String>();
        ArrayList<String> selectTableList = new ArrayList<String>();

        // Read width
        for(String nowTableNameAppendedCol : selColList) {

                String[] nowTableAndCol = nowTableNameAppendedCol.split("\u005c\u005c.");
                int width = getWidth(nowTableAndCol[0], nowTableAndCol[1]);

                colWidthList.add(width);
                selectTableList.add(nowTableAndCol[0]);
                selColListNoTableName.add(nowTableAndCol[1]);
        }


        // Head
        printLine(colWidthList);
        printColName(selectTableList, colWidthList);
        printColName(selColListNoTableName, colWidthList);
        printLine(colWidthList);

        Pattern charPattern = Pattern.compile("\u005c'([^\u005c"\u005c'\u005ct\u005cn\u005cr])*\u005c'");

        // Article
        for(int i=0; i<whereTupleList.size(); i++) {
                ArrayList<String> nowValueList = new ArrayList<String>();
                for(String colName : selColList) {
                        String retVal = myTM.getValWithColOfTuple(whereTupleList.get(i), colName);
                        if(charPattern.matcher(retVal).matches() ) {
                                retVal = retVal.substring(1,retVal.length()-1);
                        }
                        nowValueList.add(retVal);
                }
                printColName(nowValueList, colWidthList);
        }


        printLine(colWidthList);
  }

  public void printColName(ArrayList<String> _valList, ArrayList<Integer> _widthList) throws ParseException, Exception, SQLException {
        if(_valList.size() != _widthList.size() ) {
                throw new SQLException("Something wrong with column number");
        }

        for(int i=0; i<_valList.size(); i++) {
                String nowVal = _valList.get(i);
                int nowWidth = _widthList.get(i);
                String formatStr = new String("|%-"+nowWidth+"s");
                System.out.format(formatStr, nowVal);
        }
        System.out.print("|\u005cn");
  }

  public void printLine(ArrayList<Integer> _widthList) throws ParseException, Exception {
        for(int width : _widthList) {
                System.out.print("+");
                for(int i=0; i<width; i++) {
                        System.out.print("-");
                }
        }
        System.out.print("+\u005cn");
  }

  public int getWidth(String tableName, String colName) throws ParseException, Exception {
        // get width from column name's length and selected tuple list
        // compare them and choose longer width

        int tableNameWidth = tableName.length();
        int colNameWidth = colName.length();
        int tupleWidth = 0;
        int maxWidth = 0;
        String tableNameAppendedCol = new String(tableName + "." + colName);

        for(String nowTuple : whereTupleList) {
                String nowColValueOfThisTuple = myTM.getValWithColOfTuple(nowTuple, tableNameAppendedCol);
                int nowWidth = nowColValueOfThisTuple.length();

                if( nowWidth > tupleWidth) {
                        tupleWidth = nowWidth;
                }
        }

        if( tableNameWidth > maxWidth ) maxWidth = tableNameWidth;
        if( colNameWidth > maxWidth ) maxWidth = colNameWidth;
        if( tupleWidth > maxWidth ) maxWidth = tupleWidth;

        return maxWidth+2;
  }

//******************* Create table query *******************//
  final public void CreateTable() throws ParseException, SQLException, Exception {
    jj_consume_token(CREATE);
    jj_consume_token(TABLE);
    thisTableName = TableName();
        String existName = autoCaseModify( myEnv.getDbNames(), thisTableName) ;

        if(existName != null) {
                {if (true) throw new TableExistenceError();}
        }
    TableElementList();
  }

  final public String TableName() throws ParseException {
    jj_consume_token(LEGAL_IDENTIFIER);
                {if (true) return token.toString();}
    throw new Error("Missing return statement in function");
  }

  final public void TableElementList() throws ParseException, SQLException, Exception {
        // Initialize of global variables
        pkDefOccur = 0;
        fkDefOccur = 0;
        colDefOccur = 0;
        refedPtOccur = 0;
        refingPtOccur = 0;

        thisConstraintHash = new HashMap<String, String>();
        thisColDefHash = new HashMap<String, String>();
        thisFkDefHash = new HashMap<String, String>();

        thisRefedPtHash = new HashMap<String, ArrayList<String>  >();

        thisRefingPtList = new ArrayList<String>();
        thisRefedPtList = new ArrayList<String>();

        priColList = new ArrayList<String>();
        forColList = new ArrayList<String>();
        refedColList = new ArrayList<String>();
    jj_consume_token(LEFT_PAREN);
    TableElement();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      TableElement();
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void TableElement() throws ParseException, SQLException, Exception {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      ColumnDefinition();
      break;
    case PRIMARY:
    case FOREIGN:
      TableConstraintDefinition();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ColumnDefinition() throws ParseException, SQLException {
        String colDef;
        String colName;
        String dt;
        String nullable = "Y";
        String key = "NOR";
    colName = ColumnName();
    dt = DataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      nullable = NotNull();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
                String[] searched = myCM.getConstraintWithName(thisColDefHash, COLDEF_PREFIX, colName);

                if(searched != null) {
                        {if (true) throw new DuplicateColumnDefError();}
                }

                colDefOccur++;

                String colDefKey = myCM.mergeToConstraintKey(COLDEF_PREFIX, colDefOccur, colName);
                colDef = myCM.mergeToColDef(colName,dt,nullable,key);
                thisColDefHash.put(colDefKey, colDef);
  }

  final public String NotNull() throws ParseException {
    jj_consume_token(NOT);
    jj_consume_token(NULL);
          {if (true) return "N";}
    throw new Error("Missing return statement in function");
  }

  final public String ColumnName() throws ParseException {
    jj_consume_token(LEGAL_IDENTIFIER);
                {if (true) return token.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String DataType() throws ParseException, SQLException {
        int charLen;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
          {if (true) return "int";}
      break;
    case CHAR:
      jj_consume_token(CHAR);
      jj_consume_token(LEFT_PAREN);
      jj_consume_token(INT_VALUE);
                charLen = Integer.parseInt( token.toString() );
                if ( charLen < 1 ) {
                        {if (true) throw new CharLengthError();}
                }
      jj_consume_token(RIGHT_PAREN);
          {if (true) return new String("char("+charLen+")");}
      break;
    case DATE:
      jj_consume_token(DATE);
          {if (true) return "date";}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TableConstraintDefinition() throws ParseException, SQLException, Exception {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
      PrimaryKeyConstraint();
      break;
    case FOREIGN:
      ReferentialConstraint();
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PrimaryKeyConstraint() throws ParseException, SQLException {
    jj_consume_token(PRIMARY);
    jj_consume_token(KEY);
    priColList = ColumnNameList();
                pkDefOccur++;
                if(pkDefOccur > 1){
                        {if (true) throw new DuplicatePrimaryKeyDefError();}
                }

                // case modifying primary column name list 
                for(int i=0; i<priColList.size(); i++) {
                        String nowPriCol = priColList.get(i);
                        String[] searched = myCM.getConstraintWithName(thisColDefHash, COLDEF_PREFIX, nowPriCol);

                        if(searched == null) {
                                {if (true) throw new NonExistingColumnDefError(nowPriCol);}
                        } else {
                                priColList.set(i,searched[1] );
                        }
                }


                // setting key type to foreign key type
                for (String itStr : priColList) {
                        String[] searched = myCM.getConstraintWithName(thisColDefHash, COLDEF_PREFIX, itStr);

                        int cId = Integer.parseInt(searched[0]);
                        String colName = searched[1];
                        String colDef = searched[2];

                        //set key type
                        String kt = myCM.getColDefAttr(colDef, KEYTYPE);
                        if(kt.equals("FOR") ) {
                                colDef = myCM.modifyColDefAttr(colDef, KEYTYPE, "PRI/FOR");
                        } else if (kt.equals("NOR") ) {
                                colDef = myCM.modifyColDefAttr(colDef, KEYTYPE, "PRI");
                        }

                        //set nullity as not null
                        colDef = myCM.modifyColDefAttr(colDef, NULLITY, "N");

                        String colDefKey = myCM.mergeToConstraintKey( COLDEF_PREFIX, cId, colName );
                        thisColDefHash.put(colDefKey, colDef);
                }
  }

  final public void ReferentialConstraint() throws ParseException, SQLException, Exception {
        Database refedDb = null;
        Cursor refedDbCursor = null;

        thisRefedPtList = new ArrayList<String>();

        ArrayList<String> refedColDefList = new ArrayList<String>();
        HashMap<String, String> refedTableColDefHash = new HashMap<String, String>();
    jj_consume_token(FOREIGN);
    jj_consume_token(KEY);
    forColList = ColumnNameList();
    jj_consume_token(REFERENCES);
    refedTableName = TableName();
    refedColList = ColumnNameList();
                // 1. read all column definition from referenced database
                try {
                        refedDb = myEnv.setDb(refedTableName, READONLY);
                        HashMap<String,String> allHash = myCM.getAllHashFromDb(refedDb);
                        refedTableColDefHash = myCM.getHashByKind( allHash, COLDEF_PREFIX);
                } finally {
                        refedDb.close();
                }


                // 2. case modifying part
                for(int i=0; i<forColList.size(); i++) {
                        String nowForCol = forColList.get(i);
                        String[] searched = myCM.getConstraintWithName(thisColDefHash, COLDEF_PREFIX, nowForCol);
                        if(searched == null) { {if (true) throw new NonExistingColumnDefError(nowForCol);} }
                        else { forColList.set(i,searched[1] ); }
                }

                {
                        refedTableName = autoCaseModify( myEnv.getDbNames(), refedTableName) ;
                        if(refedTableName == null) { {if (true) throw new ReferenceTableExistenceError();} }
                }

                for(int i=0; i<refedColList.size(); i++) {
                        String nowRefedCol = refedColList.get(i);
                        String[] searched = myCM.getConstraintWithName(refedTableColDefHash, COLDEF_PREFIX, nowRefedCol);
                        if(searched == null) { {if (true) throw new ReferenceColumnExistenceError();} }
                        else { refedColList.set(i,searched[1] ); }
                }


                // 3. error throwing part
                if ( forColList.size() != refedColList.size() ) {
                        {if (true) throw new ReferenceTypeError();}
                } else if ( thisTableName.equalsIgnoreCase(refedTableName) ) {
                        {if (true) throw new SelfReferencingError();}
                } else if (thisRefedPtHash.containsKey(refedTableName)) {
                        {if (true) throw new DuplicatedReferenceTableError();} // Let assume foreign key references other key only once.  
                }



                // 4. check referential constraint
                for(int i=0; i<forColList.size(); i++) {
                        String nowForColName = forColList.get(i);
                        String[] searchedFor =
                                myCM.getConstraintWithName(thisColDefHash, COLDEF_PREFIX, nowForColName);
                        int nowForCorId = Integer.parseInt(searchedFor[0]);
                        String nowForColDef = searchedFor[2];
                        String nowForColDt = myCM.getColDefAttr(nowForColDef, DATATYPE);

                        String nowRefedColName = refedColList.get(i);
                        String[] searchedRefed =
                                myCM.getConstraintWithName(refedTableColDefHash, COLDEF_PREFIX, nowRefedColName);
                        int nowRefedColId = Integer.parseInt(searchedRefed[0]);
                        String nowRefedColDef = searchedRefed[2];
                        String nowRefedColDt = myCM.getColDefAttr(nowRefedColDef, DATATYPE);
                        String nowRefedColKt = myCM.getColDefAttr(nowRefedColDef, KEYTYPE);

                        if( !nowRefedColDt.equals( nowForColDt ) ) {
                                {if (true) throw new ReferenceTypeError();}
                        }

                        if(!nowRefedColKt.equals("PRI") && !nowRefedColKt.equals("PRI/FOR") ) {
                                {if (true) throw new ReferenceNonPrimaryKeyError();}
                        }
                }


                fkDefOccur++;

        // 5. setup reference relationship
        // 	1) input into forKeyHash 
        // 	2) update thisColDefHash's KeyType info 
        // 	3) input thisRefingPt into thisRefingPtList 
        // 	4) input thisRefedPt into thisRefedPtList 
        // 	5) input thisRefedPtList into thisRefedTableHash with refedTableName 

        // 1) input into forKeyHash

                // "null" for key name
                String fkDefKey = myCM.mergeToConstraintKey( FORKEY_PREFIX, fkDefOccur, "null");
                String fkDef = myCM.mergeToFKDef(forColList, refedTableName, refedColList);
                thisFkDefHash.put(fkDefKey, fkDef);

                // 2) 3) 4)
        for(int i=0; i<forColList.size(); i++ ) {
                        String nowRefingColName = forColList.get(i) ;
            String nowRefedColName = refedColList.get(i);

            // 2) update thisColDefHash's KeyType info

            String[] searchedRefing =
                myCM.getConstraintWithName(thisColDefHash, COLDEF_PREFIX, nowRefingColName);

            int nowRefingColId = Integer.parseInt(searchedRefing[0]);
            String nowRefingColDef = searchedRefing[2];

            String kt = myCM.getColDefAttr(nowRefingColDef, KEYTYPE);
            if(kt.equals("PRI") ) {
                                nowRefingColDef = myCM.modifyColDefAttr(nowRefingColDef, KEYTYPE, "PRI/FOR");
                        } else if (kt.equals("NOR") ) {
                                nowRefingColDef = myCM.modifyColDefAttr(nowRefingColDef, KEYTYPE, "FOR");
                        }

                        String nowRefingColDefKey =
                                myCM.mergeToConstraintKey(COLDEF_PREFIX, nowRefingColId, nowRefingColName);
                        thisColDefHash.put(nowRefingColDefKey, nowRefingColDef);

            // 3) input thisRefingPt into thisRefingPtList
                        String nowRefingPt =
                                myCM.mergeToRefPt(REFINGPT_PREFIX, nowRefingColName, refedTableName, nowRefedColName);
                        thisRefingPtList.add(nowRefingPt);


                        // 4) input thisRefedPt into thisRefedPtList
                        String nowRefedPt =
                                myCM.mergeToRefPt(REFEDPT_PREFIX, nowRefedColName, thisTableName, nowRefingColName);
                        thisRefedPtList.add(nowRefedPt);

        }

        // 5) input thisRefedPtList into thisRefedTableHash with refedTableName
        thisRefedPtHash.put(refedTableName, thisRefedPtList);
  }

  final public ArrayList<String> ColumnNameList() throws ParseException {
        ArrayList<String> colNameList = new ArrayList<String>();
        String colName;
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
                colNameList.add(colName);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
                        colNameList.add(colName);
    }
    jj_consume_token(RIGHT_PAREN);
                {if (true) return colNameList;}
    throw new Error("Missing return statement in function");
  }

//******************* Drop table, show tables, desc query *******************//
  final public void DropTable() throws ParseException, SQLException {
    jj_consume_token(DROP);
    jj_consume_token(TABLE);
    thisTableName = TableName();
                /* //remove later
		if(thisTableName.equals("all") ) {
			return;
		}
		*/

                thisTableName = autoCaseModify( myEnv.getDbNames(), thisTableName) ;
                if(thisTableName == null) {
                        {if (true) throw new NoSuchTable();}
                }
  }

  final public void ShowTables() throws ParseException {
    jj_consume_token(SHOW);
    jj_consume_token(TABLES);
  }

  final public void Desc() throws ParseException, SQLException {
    jj_consume_token(DESC);
    thisTableName = TableName();
                /* //remove later
		if(thisTableName.equals("all")) {
			return; 
		}
		*/

                thisTableName = autoCaseModify( myEnv.getDbNames(), thisTableName);
                if(thisTableName == null) {
                        {if (true) throw new NoSuchTable();}
                }
  }

//******************* Insert, Delete query *******************//
  final public void Insert() throws ParseException, SQLException {
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    thisTableName = TableName();
    InsertColumnsAndSource();
        thisTableName = autoCaseModify( myEnv.getDbNames(), thisTableName);
                if(thisTableName == null) {
                        {if (true) throw new NoSuchTable();}
                }
  }

  final public void InsertColumnsAndSource() throws ParseException, SQLException {
        insColList = null;
        insValList = new ArrayList<String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      insColList = ColumnNameList();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    insValList = ValueList();
  }

  final public ArrayList<String> ValueList() throws ParseException, SQLException {
        String val;
        ArrayList<String> valList = new ArrayList<String>();
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    val = Value();
                valList.add(val);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      val = Value();
                        valList.add(val);
    }
    jj_consume_token(RIGHT_PAREN);
                {if (true) return valList;}
    throw new Error("Missing return statement in function");
  }

  final public String Value() throws ParseException, SQLException {
        String cValue;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
          {if (true) return "null";}
      break;
    case CHAR_STRING:
    case INT_VALUE:
    case DATE_VALUE:
      cValue = ComparableValue();
          {if (true) return cValue;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void Delete() throws ParseException, Exception {
    jj_consume_token(DELETE);
    TableExpression(QUERY_DEL);
  }

//******************* Select query *******************//
  final public void Select() throws ParseException, SQLException, Exception {
    jj_consume_token(SELECT);
    SelectList();
    TableExpression(QUERY_SEL);
  }

  final public void SelectList() throws ParseException {
        selColList = new ArrayList<String>();
        String selCol;
        selectAllColumn = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      jj_consume_token(STAR);
          selectAllColumn = true;
      break;
    case LEGAL_IDENTIFIER:
      selCol = SelectedColumn();
          selColList.add(selCol);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_6;
        }
        jj_consume_token(COMMA);
        selCol = SelectedColumn();
            selColList.add(selCol);
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String SelectedColumn() throws ParseException {
        String colRef;
    colRef = ColumnReference();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      ColumnName();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
                {if (true) return colRef;}
    throw new Error("Missing return statement in function");
  }

  final public String ColumnReference() throws ParseException {
        String tableName = null;
        String colName;
    if (jj_2_2(2147483647)) {
      tableName = TableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    colName = ColumnName();
                if (tableName == null) {
                        {if (true) return colName;}
                } else {
                        {if (true) return new String(tableName + '.' + colName);}
                }
    throw new Error("Missing return statement in function");
  }

  final public void TableExpression(int type) throws ParseException, SQLException, Exception {
        whereAllTuple = true; // used when where clause is not defined
        whereTupleList = new ArrayList<String>();
    FromClause(type);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      WhereClause();
                  whereAllTuple = false;
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
                if(type==QUERY_DEL) {
                        thisTableName = fromTableList.get(0);
                }

                if(whereAllTuple) {
                        // All tuples are selected
                        whereTupleList = new ArrayList<String>(allCrossedTupleList);
                } else {
                        // Pick specific tuples
                        whereTupleList = mySM.pickTupleByWhereQuery(whereQuery, allCrossedTupleList);
                }
  }

  final public void FromClause(int type) throws ParseException, SQLException, Exception {
        allColOfFromTable = new ArrayList<String>();
        fromTableList = new ArrayList<String>();
        allCrossedTupleList = new ArrayList<String>();
        fromTableAllColDefHash = new HashMap<String, HashMap<String,String> > ();
    jj_consume_token(FROM);
    TableReferenceList(type);
                // Case modifying of fromTableList
                ArrayList<String> mFromTableList = new ArrayList<String>();
                for(String nowTableName : fromTableList) {
                        String mFromTableName = autoCaseModify( myEnv.getDbNames() , nowTableName);
                        if(mFromTableName == null) {
                                if(type == QUERY_SEL) { {if (true) throw new SelectTableExistenceError(nowTableName);} }
                                else { {if (true) throw new NoSuchTable();} }
                        }
                        mFromTableList.add(mFromTableName);
                }
                fromTableList = new ArrayList<String>(mFromTableList);
                allColOfFromTable = mySM.getAllTableNameAppendedCol(fromTableList);

                // Column name editing part
                if( type == QUERY_SEL) {
                        if( selectAllColumn ) {
                                selColList = allColOfFromTable;
                        } else {
                                // Modifying column name with table name appended name
                                // Error handling involved :SelectTableExistenceError, selectColumnResolveError
                                selColList = mySM.appendTableNameToAllSelCol(selColList, fromTableList);
                        }
                }

                // Read all tuples of from tables with cross producted  
                HashMap<String, ArrayList<String> > allTableTupleHash = new HashMap<String, ArrayList<String> >();
                for(String nowTableName : fromTableList) {
                        Database tableDb = myEnv.setDb(nowTableName, READONLY);
                        HashMap<String,String> nowAllKVHash;

                        try {
                                nowAllKVHash = myCM.getAllHashFromDb(tableDb);
                        } finally {
                        tableDb.close();
                }

                        HashMap<String,String> nowColDefHash = myCM.getHashByKind(nowAllKVHash, COLDEF_PREFIX);
                        fromTableAllColDefHash.put(nowTableName, nowColDefHash);
                        ArrayList<String> nowAllTpList = myCM.getTupleListFromHash(nowAllKVHash, TUPLE_PREFIX, false);
                        // Append table names to each cvPair
                        ArrayList<String> appendedTpList = mySM.appendTableNameToAllTuple(nowTableName, nowAllTpList);


                        allTableTupleHash.put(nowTableName, appendedTpList );
                }

                mySM.setFromTableList(fromTableList);
                mySM.setAllColOfFromTable(allColOfFromTable);
                mySM.setFromTableAllColDefHash(fromTableAllColDefHash);

                allCrossedTupleList = mySM.crossingTable(allTableTupleHash);
  }

  final public void TableReferenceList(int type) throws ParseException, SQLException {
        String refTable;
    refTable = ReferedTable();
          fromTableList.add(refTable);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA);
      refTable = ReferedTable();
                        fromTableList.add(refTable);
                        // When query is delete, throw error when multiple table are declared  
                        if(type == QUERY_DEL)
                        {       {if (true) throw new DeleteMultipleTableRefered();} }
    }
  }

  final public String ReferedTable() throws ParseException, SQLException {
        String orgTableName;
        String asTableName = null;
    orgTableName = TableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      asTableName = TableName();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
                if (asTableName == null) {
                        {if (true) return orgTableName;}
                } else {
                        {if (true) return new String(orgTableName + '=' + asTableName);}
                }
    throw new Error("Missing return statement in function");
  }

// Where cluase check query if it is fitted in syntax grammer 
// and use it on iterative method in mySM.pickTupleByWhereQuery
// see TableExpression()
  final public void WhereClause() throws ParseException, SQLException, Exception {
        whereQuery = new String();
    jj_consume_token(WHERE);
    BooleanValueExpression();
  }

  final public void BooleanValueExpression() throws ParseException, SQLException, Exception {
    BooleanTerm();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_8;
      }
      jj_consume_token(OR);
                  whereQuery = whereQuery.concat(token.toString() + "\u005c"");
      BooleanTerm();
    }
  }

  final public void BooleanTerm() throws ParseException, SQLException, Exception {
    BooleanFactor();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_9;
      }
      jj_consume_token(AND);
                  whereQuery = whereQuery.concat(token.toString() + "\u005c"");
      BooleanFactor();
    }
  }

  final public void BooleanFactor() throws ParseException, SQLException, Exception {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
                  whereQuery = whereQuery.concat(token.toString() + "\u005c"");
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    BooleanTest();
  }

  final public void BooleanTest() throws ParseException, SQLException, Exception {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      ParenthesizedBooleanExpression();
      break;
    case CHAR_STRING:
    case INT_VALUE:
    case DATE_VALUE:
    case LEGAL_IDENTIFIER:
      Predicate();
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ParenthesizedBooleanExpression() throws ParseException, SQLException, Exception {
    jj_consume_token(LEFT_PAREN);
          whereQuery = whereQuery.concat(token.toString() + "\u005c"");
    BooleanTerm();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_10;
      }
      jj_consume_token(OR);
                  whereQuery = whereQuery.concat(token.toString() + "\u005c"");
      BooleanTerm();
    }
    jj_consume_token(RIGHT_PAREN);
          whereQuery = whereQuery.concat(token.toString() + "\u005c"");
  }

  final public void Predicate() throws ParseException, SQLException, Exception {
    if (jj_2_3(2147483647)) {
      ComparisonPredicate();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEGAL_IDENTIFIER:
        NullPredicate();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void ComparisonPredicate() throws ParseException, SQLException, Exception {
    CompOperand();
    jj_consume_token(COMP_OP);
      whereQuery = whereQuery.concat( token.toString() + "\u005c"" );
    CompOperand();
  }

  final public void CompOperand() throws ParseException, SQLException {
        String cp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR_STRING:
    case INT_VALUE:
    case DATE_VALUE:
      cp = ComparableValue();
      whereQuery = whereQuery.concat( PREFIX_VAL + cp + "\u005c"" );
      break;
    case LEGAL_IDENTIFIER:
      cp = ColumnReference();
                // If cp has no table name appended, append table name. 
                String[] tableAndColName = myTM.splitNameOfAppended(cp);
                if(tableAndColName[0] == null) {
                        cp = mySM.searchAndAppendCol(tableAndColName[1]);
                } else {
                        cp = autoCaseModify(allColOfFromTable,cp);
                        if(cp == null) {
                                {if (true) throw new WhereColumnNotExist();}
                        }
                }

                whereQuery = whereQuery.concat( PREFIX_CR + cp + "\u005c"" );   // PREFIX_CR = "CR"

      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String ComparableValue() throws ParseException, SQLException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
      jj_consume_token(INT_VALUE);
      {if (true) return token.toString();}
      break;
    case CHAR_STRING:
      jj_consume_token(CHAR_STRING);
      {if (true) return token.toString();}
      break;
    case DATE_VALUE:
      jj_consume_token(DATE_VALUE);
      {if (true) return token.toString();}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void NullPredicate() throws ParseException, SQLException {
        String colName;
        String tableName = null;
        String nullOp;
    if (jj_2_4(2147483647)) {
      tableName = TableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    colName = ColumnName();
        if (tableName != null) {
                tableName = autoCaseModify( myEnv.getDbNames(), thisTableName) ;
                if(tableName == null) {
                                {if (true) throw new WhereTableNotSpecified();}
                        } else {
                                colName = myTM.appendTableName(tableName, colName);
                                colName = autoCaseModify(allColOfFromTable, colName);
                                if(colName == null) {
                                        {if (true) throw new WhereColumnNotExist();}
                                }
                        }
                } else {
                        colName = mySM.searchAndAppendCol(colName);
                }

                whereQuery = whereQuery.concat( colName + "\u005c"");
    nullOp = NullOperation();
        whereQuery = whereQuery.concat( nullOp + "\u005c"");
  }

  final public String NullOperation() throws ParseException, SQLException {
        boolean not = false;
    jj_consume_token(IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
       not = true;
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(NULL);
        if(not) {
                {if (true) return new String("is not null");}
        } else {
                {if (true) return new String("is null");}
        }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_3R_20() {
    if (jj_3R_11()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  private boolean jj_3R_18() {
    if (jj_scan_token(CHAR_STRING)) return true;
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(INT_VALUE)) return true;
    return false;
  }

  private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) return true;
    }
    return false;
  }

  private boolean jj_3R_13() {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_11() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_20()) jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_11()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(EXIT)) return true;
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_11()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_12()) return true;
    if (jj_scan_token(COMP_OP)) return true;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_scan_token(DATE_VALUE)) return true;
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_3R_16()) return true;
    return false;
  }

  /** Generated Token Manager. */
  public SQLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[29];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x82400000,0x82400000,0x0,0x20,0x82400000,0x10,0x0,0x10000000,0x0,0x0,0x10,0x4,0x10,0xe0000,0x10,0x80,0x0,0x1000000,0x10,0x0,0x40000000,0x20000000,0x10000000,0xe0004,0x40000000,0x0,0xe0000,0xe0000,0x10000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x3a,0x3a,0x20000,0x0,0x3a,0x0,0x40600,0x0,0x7000,0x600,0x0,0x0,0x0,0x4,0x0,0x40000,0x100,0x0,0x0,0x100,0x0,0x0,0x0,0x40000,0x0,0x40000,0x40000,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SQLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SQLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SQLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SQLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SQLParser(SQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SQLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[51];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 29; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 51; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

        }
