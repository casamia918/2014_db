import java.io.*;
import java.util.*;
import java.util.Map.*;
import java.util.regex.*;
import java.text.*;

import com.sleepycat.je.*;

public class ConstraintManager implements MyConstants {
	
	private static DatabaseEntry theKey = new DatabaseEntry();
	private static DatabaseEntry theData = new DatabaseEntry();
	private static OperationStatus retVal;
	

	public ConstraintManager() {}

	public static void main(String[] args) throws Exception {

		ConstraintManager cm = new ConstraintManager();
		cm.test();

	}

	public void test() {
		
	}



	/*
			< column definition manipulation method >

	Every column definition related variables are handled by these methods.

	getter : getColDef, getColDefAttr
	modifier : modifyColAttr, mergeToColDef
  	(setting column definition method is declared in constraint manipulation part)

	*/

	public String getColDef(HashMap<String,String> _constraintHash, String colName)
			throws SQLException {
		String[] searched = getConstraintWithName(_constraintHash, COLDEF_PREFIX, colName);
		if (searched != null) {
			return searched[2]; 
		} else {
			throw new SQLException("Has no column definition with that column name : " + colName);
		}
	} 

	public String getColDefAttr(String colDef, int kind) {
		//0:colName, 1:dataType, 2:nullity, 3:keyType
		String[] attr = colDef.split("\"");
		return attr[kind];
	}

	public ArrayList<String> getColNameList(HashMap<String,String> _colDefHash) {
		ArrayList<String> result = new ArrayList<String>();
		for(int i=1; i<=_colDefHash.size(); i++ ) {
			String[] nowColDefConstraint = getConstraintWithId(_colDefHash, COLDEF_PREFIX, i);
			
			//colDefConstraint : "id name colDef"
			String nowColName = nowColDefConstraint[1];
			result.add(nowColName);
		}
		return result;
	}
	
	public String modifyColDefAttr(String colDef, int kind, String newAttr) {
		String[] attr = colDef.split("\"");
		attr[kind] = newAttr; // type check need
		String newColDef = attr[0];
		for(int i=1; i<4; i++){
			newColDef = newColDef.concat("\""+attr[i]);
		}
		return newColDef;
	} 

	public String mergeToColDef(String colName, String dataType, String nullity, String keyType) {
		return new String(colName +"\"" + dataType + "\"" + nullity + "\"" + keyType); 
	}



	/*
			< foreign key manipulation method >

	Every foreign key related variables are handled by these methods.
	Foreign keys are composed by 3 parts

	foreign key (<COLUMN_NAME_LIST>) referenced <REFED_TABLENAME> (<COLUMN_NAME_LIST>)
	  				forColList				   refedTableName  refedColList

	getter : getForKey, getForColList, getRefedTableName, getRefedColList
  	modifier : partoToForKey (to aggregate foreign key information into one string),
  	(setting foreign key method is declared in constraint manipulation part)

	( for : foreign, col : column, refed : referenced, refing : referencing)
	 */

	public String getFKDef(HashMap<String,String> _constraintHash, int id) 
			throws SQLException { // id >= 1
		String[] searched = 
				getConstraintWithId(_constraintHash, FORKEY_PREFIX, id );
		if(searched!=null) {
			return searched[2];
		} else {
			throw new SQLException("Has no foreign key with that id : " + id);
		}

	}

	private String getFKDefPart(String fkDef, int part) {
		String[] fkDefArr = fkDef.split("\"");
		return fkDefArr[part];
	}

	public ArrayList<String> getForColList (String fkDef) {
		String forCol = getFKDefPart(fkDef, FORCOL);
		String[] forColArr = forCol.split(",");
		return new ArrayList<String>(Arrays.asList(forColArr));
	}

	public String getRefedTableName (String fkDef) {
		return getFKDefPart(fkDef, REFEDTABLENAME);
	}

	public ArrayList<String> getRefedColList (String fkDef) {
		String refedCol = getFKDefPart(fkDef, REFEDCOL);
		String[] refedColArr = refedCol.split(",");
		return new ArrayList<String>(Arrays.asList(refedColArr));
	}

	public String mergeToFKDef (ArrayList<String> forColList, 
			String refedTableName, 
			ArrayList<String> refedColList ) {
		
		String fk = new String();	
		for(int i=0; i<forColList.size(); i++) {
			fk = fk.concat(forColList.get(i) + ",");
		}
		fk = fk.substring(0, fk.length()-1);

		fk = fk.concat("\"" + refedTableName + "\"");

		for(int i=0; i<refedColList.size(); i++) {
			fk =fk.concat(refedColList.get(i) + ",");
		}
		fk = fk.substring(0, fk.length()-1);

		return fk;
	}

	/*
			< constraint manipulation method >

	Constraint definition like column definition or foreign key definition are
	manipulated by these method 		

	getter : getConstarintWithName, getConstraintWithId
	setter : setConstraint (Key is generated by mergeToConstraintKey)
	modifier : mergeToConstraintKey (Key is combined with prefix, id, name)

	 */		
	public String[] getConstraintWithName
	(HashMap<String, String> _constraintHash, String prefix, String name) 
			throws SQLException {
		//result[0] : id
		//result[1] : name
		//result[2] : definition value
		String[] result = new String[3];

		// this method is not allowed to refing hash or refed hash
		// because they uses duplicated names
		if(prefix.equals(REFINGPT_PREFIX) || prefix.equals(REFEDPT_PREFIX) ) {
			throw new SQLException("Getting Refing Pointer and Refed Pointer must use its own method");
		} 

		// assume colName is unique
		for (String itStr : _constraintHash.keySet() ) {
			String[] splited = itStr.split("\"");
			if ( prefix.equals(splited[0]) && name.equalsIgnoreCase(splited[2]) ) {

				result[0] = splited[1];
				result[1] = splited[2]; 
				result[2] = _constraintHash.get(itStr); 
				return result;
			}
		}
		return null;
	}

	public String[] getConstraintWithId
	(HashMap<String, String> _constraintHash, String prefix, int id) {
		//result[0] : id
		//result[1] : name
		//result[2] : definition value
		String[] result = new String[3];

		for (String itStr : _constraintHash.keySet() ) {
			// splited[0] : prefix, splited[1] : id, splited[2] : "null"
			String[] splited = itStr.split("\"");
			if ( prefix.equals(splited[0]) && id == Integer.parseInt(splited[1]) ) {
				result[0] = splited[1];
				result[1] = splited[2]; 
				result[2] = _constraintHash.get(itStr); 
				return result;
			}
		}
		return null;
	}

	/* public void setConstraint 
	(HashMap<String,String> _constraintHash, String constKey, String constDef) {
		_constraintHash.put( constKey , constDef);
	}
	*/

	public String mergeToConstraintKey(String prefix, int id, String name) {
		return new String(prefix + "\"" + id + "\"" + name);
	}



	/*
			< Reference pointer manipulation method >

	By defining foreign key constraint, reference relationship is created.
	Reference pointer is composed by three strings parts.

		refPt = subjectCol + "\"" + String objTable+ "\"" String objectCol

	When refPt is refingPt, then each part refers to refingColName, refedTableName, refedColName
	When refPt is refedPt, then each part refers to refedColName, refingTableName, refingColName

	Reference pointer is stored in refPtList, which type is ArrayList<String>.
	This means reference pointer doesn't need to distinguish key and value.

	getter : getrefPtListFromHash
			 getRefPtByKind
			 getRefPtPart
	setter : no need to define
	modifier : mergeToRefPt 


	 */

	public ArrayList<String> getRefPtListFromHash(HashMap<String,String> allKVHash, String prefix) {

		ArrayList<String> result = new ArrayList<String>() ;

		for(Entry<String,String> entry : allKVHash.entrySet() ) {
			String nowKey = entry.getKey();
			String[] splited = nowKey.split("\"");
			if( prefix.equals(splited[0]) ) {
				result.add(nowKey);
			}
		}
		return result;
	}
	
	// Referencing or referenced pointer of same subject column can be declared multiple times.
	// Thus, return type is need to array.
	public ArrayList<String> getRefPtByKind (ArrayList<String> refPtList, int kind, String arg) {
		//1:subject, 2:object_tablename, 3: object 
		ArrayList<String> result = new ArrayList<String>();
		for(String nowRefPt : refPtList) {
			if( arg.equalsIgnoreCase( getRefPtPart(nowRefPt, kind) ) ) {
				result.add(nowRefPt);
			}
		}
		return result;
	}


	String getRefPtPart(String refPt, int part) {
		// 0 : prefix
		// 1 : subjectCOl
		// 2 : objectTable
		// 3 : objectCol
		String[] splited = refPt.split("\"");
		if(part < splited.length) {
			return splited[part];
		} else {
			return null;
		}
	}

	String mergeToRefPt(String prefix, String subjectCol, String objectTable, String objectCol) {
		return new String(prefix + "\"" + subjectCol + "\"" + objectTable + "\"" + objectCol ); 
	}


	/*
			< Hash map read method >

	HashMap which stores sql queries are read by these method.

	getter : getAllHashFromDb, getHashByKind

	 */

	public HashMap<String,String> getAllHashFromDb (Database targetDb) 
			throws SQLException, Exception {

		HashMap<String,String> resultHash = new HashMap<String,String>();

		Cursor cursor = targetDb.openCursor(null,null); // assume targetDb is not null

		try {
			retVal = cursor.getFirst(theKey, theData, LockMode.DEFAULT);
			String nowKey, nowData;
			while(retVal == OperationStatus.SUCCESS) {
				nowKey = new String(theKey.getData(), "UTF-8");
				nowData = new String(theData.getData(), "UTF-8");
				resultHash.put(nowKey, nowData);

				retVal = cursor.getNext(theKey, theData, LockMode.DEFAULT);
			}
		} finally {
			cursor.close();
		}

		if(resultHash.size() == 0 ) {
			throw new SQLException("Has no DataEntry in " + targetDb.getDatabaseName() );
		}

		return resultHash;
	}

	public HashMap<String,String> getHashByKind(HashMap<String,String> sourceHash, String prefix) 
			throws SQLException {

		HashMap<String,String> resultHash = new HashMap<String,String>();

		Iterator<Entry<String,String> > it = sourceHash.entrySet().iterator();
		while(it.hasNext()) {
			Entry<String,String> thisEntry = it.next(); 
			String thisKey = thisEntry.getKey();
			String thisValue = thisEntry.getValue();
			if(thisKey.startsWith(prefix)) {
				resultHash.put(thisKey, thisValue);
			}
			
		}

		return resultHash;

	}
	
	public ArrayList<String> getTupleListFromHash(HashMap<String,String> sourceHash, String prefix, boolean remainPrefix) 
			throws SQLException {

		ArrayList<String> resultList = new ArrayList<String> ();
		int len = prefix.length();
		
		Iterator<Entry<String,String> > it = sourceHash.entrySet().iterator();
		while(it.hasNext()) {
			Entry<String,String> thisEntry = it.next(); 
			String thisKey = thisEntry.getKey();
			if(thisKey.startsWith(prefix)) {
				if(remainPrefix ) {
					resultList.add(thisKey);
				} else {
					resultList.add(thisKey.substring(len+1, thisKey.length() ) ); // remove prefix and delimiter "
					
				}
			}
		}

		return resultList;

	}
	



}
